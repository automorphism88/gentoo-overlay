From 53f6e096b3e301acd51c70487297faaa0cc727f1 Mon Sep 17 00:00:00 2001
From: David Sterba <dsterba@suse.com>
Date: Tue, 14 Nov 2017 19:10:01 +0100
Subject: [PATCH 07/12] btrfs/zstd support, compiles, incomplete

Signed-off-by: David Sterba <dsterba@suse.com>
---
 grub-core/fs/btrfs.c | 156 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 156 insertions(+)

diff --git a/grub-core/fs/btrfs.c b/grub-core/fs/btrfs.c
index 8766403b3..87dc15db9 100644
--- a/grub-core/fs/btrfs.c
+++ b/grub-core/fs/btrfs.c
@@ -46,6 +46,16 @@ GRUB_MOD_LICENSE ("GPLv3+");
 #define GRUB_BTRFS_LZO_BLOCK_MAX_CSIZE (GRUB_BTRFS_LZO_BLOCK_SIZE + \
 				     (GRUB_BTRFS_LZO_BLOCK_SIZE / 16) + 64 + 3)
 
+/*
+ * Duplicate
+ */
+#define ZSTD_BTRFS_MAX_WINDOWLOG 17
+#define ZSTD_BTRFS_MAX_INPUT (1 << ZSTD_BTRFS_MAX_WINDOWLOG)
+#define ZSTD_BTRFS_DEFAULT_LEVEL 3
+
+#define GRUB_BTRFS_ZSTD_BLOCK_SIZE		4096
+#define GRUB_BTRFS_ZSTD_BLOCK_MAX_CSIZE		8192
+
 typedef grub_uint8_t grub_btrfs_checksum_t[0x20];
 typedef grub_uint16_t grub_btrfs_uuid_t[8];
 
@@ -213,6 +223,7 @@ struct grub_btrfs_extent_data
 #define GRUB_BTRFS_COMPRESSION_NONE 0
 #define GRUB_BTRFS_COMPRESSION_ZLIB 1
 #define GRUB_BTRFS_COMPRESSION_LZO  2
+#define GRUB_BTRFS_COMPRESSION_ZSTD  3
 
 #define GRUB_BTRFS_OBJECT_ID_CHUNK 0x100
 
@@ -913,6 +924,138 @@ grub_btrfs_read_inode (struct grub_btrfs_data *data,
   return grub_btrfs_read_logical (data, elemaddr, inode, sizeof (*inode), 0);
 }
 
+static grub_ssize_t
+grub_btrfs_zstd_decompress(char *ibuf, grub_size_t isize, grub_off_t off,
+			  char *obuf, grub_size_t osize)
+{
+  grub_uint32_t total_size, cblock_size;
+  grub_size_t ret = 0;
+  char *ibuf0 = ibuf;
+  ZSTD_inBuffer in_buf;
+  ZSTD_outBuffer out_buf;
+  ZSTD_DStream *stream;
+  void *wmem;
+  grub_size_t wsize;
+
+  /*
+   * TODO: allocators
+   */
+  wsize = ZSTD_DStreamWorkspaceBound(ZSTD_BTRFS_MAX_INPUT);
+  wmem = grub_malloc(wsize);
+  if (!wmem)
+    {
+       return -1;
+    }
+  stream = ZSTD_initDStream(ZSTD_BTRFS_MAX_INPUT, wmem, wsize);
+  if (!stream)
+    {
+       grub_free(wmem);
+       return -1;
+    }
+
+  total_size = grub_le_to_cpu32 (grub_get_unaligned32 (ibuf));
+  ibuf += sizeof (total_size);
+
+  if (isize < total_size)
+    return -1;
+
+  /* Jump forward to first block with requested data.  */
+  while (off >= GRUB_BTRFS_ZSTD_BLOCK_SIZE)
+    {
+      /* Don't let following uint32_t cross the page boundary.  */
+      if (((ibuf - ibuf0) & 0xffc) == 0xffc)
+	ibuf = ((ibuf - ibuf0 + 3) & ~3) + ibuf0;
+
+      cblock_size = grub_le_to_cpu32 (grub_get_unaligned32 (ibuf));
+      ibuf += sizeof (cblock_size);
+
+      if (cblock_size > GRUB_BTRFS_ZSTD_BLOCK_MAX_CSIZE)
+	return -1;
+
+      off -= GRUB_BTRFS_ZSTD_BLOCK_SIZE;
+      ibuf += cblock_size;
+    }
+
+  while (osize > 0)
+    {
+      unsigned int usize = GRUB_BTRFS_ZSTD_BLOCK_SIZE;
+      grub_size_t ret2;
+
+      /* Don't let following uint32_t cross the page boundary.  */
+      if (((ibuf - ibuf0) & 0xffc) == 0xffc)
+	ibuf = ((ibuf - ibuf0 + 3) & ~3) + ibuf0;
+
+      cblock_size = grub_le_to_cpu32 (grub_get_unaligned32 (ibuf));
+      ibuf += sizeof (cblock_size);
+
+      if (cblock_size > GRUB_BTRFS_ZSTD_BLOCK_MAX_CSIZE)
+	return -1;
+
+      /* Block partially filled with requested data.  */
+      if (off > 0 || osize < GRUB_BTRFS_ZSTD_BLOCK_SIZE)
+	{
+	  grub_size_t to_copy = GRUB_BTRFS_ZSTD_BLOCK_SIZE - off;
+	  grub_uint8_t *buf;
+
+	  if (to_copy > osize)
+	    to_copy = osize;
+
+	  buf = grub_malloc (GRUB_BTRFS_ZSTD_BLOCK_SIZE);
+	  if (!buf)
+	    return -1;
+
+	  /* TODO: zstd decompress */
+	  in_buf.src = ibuf;
+	  in_buf.pos = 0;
+	  in_buf.size = cblock_size;
+	  out_buf.dst = buf;
+	  out_buf.pos = 0;
+	  out_buf.size = usize;
+	  ret2 = ZSTD_decompressStream(stream, &out_buf, &in_buf);
+	  if (ZSTD_isError(ret2))
+	    {
+	    /* CLEANUP */
+	      grub_free (buf);
+	      return -1;
+	    }
+
+	  if (to_copy > usize)
+	    to_copy = usize;
+	  grub_memcpy(obuf, buf + off, to_copy);
+
+	  osize -= to_copy;
+	  ret += to_copy;
+	  obuf += to_copy;
+	  ibuf += cblock_size;
+	  off = 0;
+
+	  grub_free (buf);
+	  continue;
+	}
+
+      in_buf.src = ibuf;
+      in_buf.pos = 0;
+      in_buf.size = cblock_size;
+      out_buf.dst = obuf;
+      out_buf.pos = 0;
+      out_buf.size = usize;
+      /* Decompress whole block directly to output buffer.  */
+      ret2 = ZSTD_decompressStream(stream, &out_buf, &in_buf);
+      if (ZSTD_isError(ret2))
+        {
+	   return -1;
+	}
+      usize = out_buf.size;
+
+      osize -= usize;
+      ret += usize;
+      obuf += usize;
+      ibuf += cblock_size;
+    }
+
+  return -1;
+}
+
 static grub_ssize_t
 grub_btrfs_lzo_decompress(char *ibuf, grub_size_t isize, grub_off_t off,
 			  char *obuf, grub_size_t osize)
@@ -1128,6 +1271,15 @@ grub_btrfs_extent_read (struct grub_btrfs_data *data,
 		  != (grub_ssize_t) csize)
 		return -1;
 	    }
+	  else if (data->extent->compression == GRUB_BTRFS_COMPRESSION_ZLIB)
+	    {
+	      if (grub_btrfs_zstd_decompress(data->extent->inl, data->extsize -
+					   ((grub_uint8_t *) data->extent->inl
+					    - (grub_uint8_t *) data->extent),
+					   extoff, buf, csize)
+		  != (grub_ssize_t) csize)
+		return -1;
+	    }
 	  else
 	    grub_memcpy (buf, data->extent->inl + extoff, csize);
 	  break;
@@ -1165,6 +1317,10 @@ grub_btrfs_extent_read (struct grub_btrfs_data *data,
 		ret = grub_btrfs_lzo_decompress (tmp, zsize, extoff
 				    + grub_le_to_cpu64 (data->extent->offset),
 				    buf, csize);
+	      else if (data->extent->compression == GRUB_BTRFS_COMPRESSION_ZSTD)
+		ret = grub_btrfs_zstd_decompress (tmp, zsize, extoff
+				    + grub_le_to_cpu64 (data->extent->offset),
+				    buf, csize);
 	      else
 		ret = -1;
 
-- 
2.16.1

